"""
Add by HL
Activation Analysis of a Byte-Based Deep Neural Network for Malware Classification
Scott E, Christopher G (FireEye) 2019
"""

import os
import torch
import torch.nn as nn
import torch.nn.functional as F

from secml_malware.models.basee2e import End2EndModel

from secml.settings import SECML_PYTORCH_USE_CUDA
use_cuda = torch.cuda.is_available() and SECML_PYTORCH_USE_CUDA


class DNN(End2EndModel):

	"""
	Architecture implementation.
	"""
	def __init__(self, pretrained_path=None, embedding_size=10, max_input_size=102400,window_size=512):
		super(DNN, self).__init__(embedding_size, max_input_size, 256, False)		# padding symbol 256;
		self.embedding_1 = nn.Embedding(num_embeddings=257, embedding_dim=embedding_size)
		self.conv1d_1 = nn.Conv1d(in_channels=embedding_size, out_channels=16, kernel_size=(8,), stride=(4,), groups=1, bias=True)
		self.conv1d_2 = nn.Conv1d(in_channels=16, out_channels=32, kernel_size=(16,), stride=(4,), groups=1, bias=True)
		self.conv1d_3 = nn.Conv1d(in_channels=32, out_channels=64, kernel_size=(4,), stride=(2,), groups=1, bias=True)
		self.conv1d_4 = nn.Conv1d(in_channels=64, out_channels=128, kernel_size=(4,), stride=(2,), groups=1, bias=True)
		self.conv1d_5 = nn.Conv1d(in_channels=128, out_channels=128, kernel_size=(4,), stride=(2,), groups=1, bias=True)
		self.pooling = nn.MaxPool1d(int(max_input_size/window_size))
		self.dense_1 = nn.Linear(in_features=128*3, out_features=1, bias=True)
		self.sigmoid = nn.Sigmoid()

		if pretrained_path is not None:
			self.load_simplified_model(pretrained_path)
		if use_cuda:
			self.cuda()


	def embed(self, input_x, transpose=True):
		"""
		It embeds an input vector into MalConv embedded representation.
		"""
		if isinstance(input_x, torch.Tensor):
			x = input_x.type(torch.LongTensor)
		else:
			x = torch.autograd.variable(torch.from_numpy(input_x).type(torch.LongTensor))
		x = x.squeeze(dim=1)
		if use_cuda:
			x = x.cuda()
		emb_x = self.embedding_1(x)
		if transpose:
			emb_x = torch.transpose(emb_x, 1, 2)
		return emb_x

	def embedd_and_forward(self, x):
		x = self.conv1d_1(x)
		x = self.conv1d_2(x)
		x = self.conv1d_3(x)
		x = self.conv1d_4(x)
		x = self.conv1d_5(x)
		x = self.pooling(x)
		x = x.view(x.size(0),-1)
		x = self.dense_1(x)
		x = self.sigmoid(x)
		return x



# if __name__ == "__main__":
# 	root_file = os.path.dirname(__file__)	# current root path
# 	print(os.path.join(root_file, '../data/trained/pretrained_malconv.pth'))
# 	m = DNN(pretrained_path=os.path.join(root_file, '../data/trained/pretrained_malconv.pth'))
# 	print(m)
